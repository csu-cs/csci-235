import{_ as i,o as t,c as o,e as a,a as e}from"./app.55989122.js";const k=JSON.parse('{"title":"Scope and Parameters","description":"","frontmatter":{},"headers":[{"level":2,"title":"Void Functions","slug":"void-functions","link":"#void-functions","children":[]},{"level":2,"title":"Scope of an Identifier","slug":"scope-of-an-identifier","link":"#scope-of-an-identifier","children":[]},{"level":2,"title":"Global Variables Are Problematic","slug":"global-variables-are-problematic","link":"#global-variables-are-problematic","children":[]},{"level":2,"title":"Two Types of Function Parameters","slug":"two-types-of-function-parameters","link":"#two-types-of-function-parameters","children":[]},{"level":2,"title":"Memory Allocation for Parameters","slug":"memory-allocation-for-parameters","link":"#memory-allocation-for-parameters","children":[]},{"level":2,"title":"Creating an Animation","slug":"creating-an-animation","link":"#creating-an-animation","children":[]}],"relativePath":"notes/06-scope-and-parameters.md","lastUpdated":1672192110000}'),r={name:"notes/06-scope-and-parameters.md"},l=a('<h1 id="scope-and-parameters" tabindex="-1">Scope and Parameters <a class="header-anchor" href="#scope-and-parameters" aria-hidden="true">#</a></h1><p><em>Chapter 6</em></p><h2 id="void-functions" tabindex="-1">Void Functions <a class="header-anchor" href="#void-functions" aria-hidden="true">#</a></h2><ol><li><em>Value-returning functions</em> have a return type. <ul><li>Return a value of a specific data type using the return statement</li></ul></li><li><em>Void functions</em> do not have a return type. <ul><li>Does not use a return statement to return a value</li></ul></li></ol><p>Not all functions return a value.</p>',5),n=e("div",{class:"youtube"},[e("div",null,[e("iframe",{width:"853",height:"480",src:"https://www.youtube-nocookie.com/embed/5_HcYUkEPH4?rel=0&showinfo=0",frameborder:"0",allowfullscreen:"allowfullscreen"})])],-1),s=a('<h2 id="scope-of-an-identifier" tabindex="-1">Scope of an Identifier <a class="header-anchor" href="#scope-of-an-identifier" aria-hidden="true">#</a></h2><p>The <em>Scope</em> of an identifier is where in the program the identifier is accessible.</p><p>Types of Scopes:</p><ul><li><strong>Local identifier</strong>: identifiers declared within a function (or block)</li><li><strong>Global identifier</strong>: identifiers declared outside of every function definition</li><li>C++ does not allow nested functions, which is the definition of one function inside of another function&#39;s body.</li></ul><p>Rules when an identifier is accessed:</p><ul><li><p>Must be declared before being used.</p></li><li><p>Global identifiers are accessible by a function or block if:</p><ul><li>Declared before the function definition</li><li>All local identifiers (variables and parameters) have different names than the global identifier.</li></ul></li><li><p>Nested block</p><ul><li>Identifiers are accessible from their declaration to end of block where it is declared.</li><li>Within nested blocks if no identifier with same name exists</li></ul></li><li><p>The <em>scope</em> of a function name is like scope of an identifier declared outside any block.</p><ul><li>i.e., function name scope = global variable scope</li></ul></li><li><p>By using the <em>scope-resolution operator</em>, <code>::</code>,</p><ul><li>A global variable declared before the definition of a function (or block) can be accessed by the function (or block).</li><li>Even if the function (or block) has an identifier with the same name as the global variable.</li></ul></li></ul>',6),c=e("div",{class:"youtube"},[e("div",null,[e("iframe",{width:"853",height:"480",src:"https://www.youtube-nocookie.com/embed/ZTGujDzKMbw",frameborder:"0",allow:"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture",allowfullscreen:"allowfullscreen"})])],-1),d=a('<h2 id="global-variables-are-problematic" tabindex="-1">Global Variables Are Problematic <a class="header-anchor" href="#global-variables-are-problematic" aria-hidden="true">#</a></h2><ul><li><strong>Do NOT use global variables unless they are constants</strong>!</li><li>Using global variables causes side effects. <ul><li>A function that uses global variables is not independent</li><li>If more than one function uses the same global variable, <ul><li>Debugging problems with the global variable is more difficult.</li><li>Problems caused in one area of the program may appear to be from another area.</li></ul></li></ul></li><li>Global named constants have no side effects because they never change values.</li></ul><h2 id="two-types-of-function-parameters" tabindex="-1">Two Types of Function Parameters <a class="header-anchor" href="#two-types-of-function-parameters" aria-hidden="true">#</a></h2><p>There are two ways to send information to a function using parameters: <em>Pass-by-Value</em> and <em>Pass-by-Reference</em>.</p>',4),u=e("div",{class:"youtube"},[e("div",null,[e("iframe",{width:"853",height:"480",src:"https://www.youtube-nocookie.com/embed/x9W1qV-RO5k?rel=0&showinfo=0",frameborder:"0",allowfullscreen:"allowfullscreen"})])],-1),h=a('<ol><li><p><strong>Value parameter:</strong> a formal parameter that receives a copy of the content of the corresponding actual parameter</p><ul><li>The formal parameter has its own copy of the data.</li><li>During execution, the function manipulates the data stored in its own memory space.</li><li>The copy is lost when the function call ends.</li></ul></li><li><p><strong>Reference parameter</strong>: a formal parameter that receives the location (memory address) of the corresponding actual parameter</p><ul><li>Changes to the formal parameter will change the corresponding actual parameter. <ul><li>i.e., the changes are occurring directly on the variable passed in (not a copy).</li></ul></li><li>Reference parameters are useful in three situations: <ol><li>When returning more than one value.</li><li>When changing the actual parameter.</li><li>When passing the address saves memory space and time (use a <code>const</code> reference if you are not changing the actual parameter.)</li></ol></li></ul></li></ol><h2 id="memory-allocation-for-parameters" tabindex="-1">Memory Allocation for Parameters <a class="header-anchor" href="#memory-allocation-for-parameters" aria-hidden="true">#</a></h2><ul><li><p>When a function is called, memory for its formal parameters and its local variables is allocated in the function data area.</p></li><li><p><strong>For a value parameter</strong>, the actual parameter’s value is copied into the formal parameter’s memory cell.</p><ul><li>Changes to the formal parameter do not affect the actual parameter’s value.</li></ul></li><li><p><strong>For a reference parameter</strong>, the actual parameter’s address passes to the formal parameter.</p><ul><li>Both formal and actual parameters refer to the same memory location</li><li>During execution, changes made to the formal parameter’s value permanently change the actual parameter’s value.</li></ul></li><li><p>Design Guideline: If a function needs to return more than one value, do not use a value-returning function. Instead, use reference parameters to “return” the values.</p></li></ul><h2 id="creating-an-animation" tabindex="-1">Creating an Animation <a class="header-anchor" href="#creating-an-animation" aria-hidden="true">#</a></h2><p>This video is an example of putting the things we know together for something fun. You also learn more about timing.</p>',5),f=e("div",{class:"youtube"},[e("div",null,[e("iframe",{width:"853",height:"480",src:"https://www.youtube-nocookie.com/embed/uagjplSPneg?rel=0&showinfo=0",frameborder:"0",allowfullscreen:"allowfullscreen"})])],-1),m=[l,n,s,c,d,u,h,f];function p(b,g,_,v,w,y){return t(),o("div",null,m)}const P=i(r,[["render",p]]);export{k as __pageData,P as default};
